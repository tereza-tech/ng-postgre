"use strict";

const path = require("path");

const {
  validate
} = require("schema-utils");

const serialize = require("serialize-javascript");

const normalizePath = require("normalize-path");

const globParent = require("glob-parent");

const fastGlob = require("fast-glob"); // @ts-ignore


const {
  version
} = require("../package.json");

const schema = require("./options.json");

const {
  readFile,
  stat,
  throttleAll
} = require("./utils");

const template = /\[\\*([\w:]+)\\*\]/i;
/** @typedef {import("schema-utils/declarations/validate").Schema} Schema */

/** @typedef {import("webpack").Compiler} Compiler */

/** @typedef {import("webpack").Compilation} Compilation */

/** @typedef {import("webpack").WebpackError} WebpackError */

/** @typedef {import("webpack").Asset} Asset */

/** @typedef {import("globby").Options} GlobbyOptions */

/** @typedef {import("globby").GlobEntry} GlobEntry */

/** @typedef {ReturnType<Compilation["getLogger"]>} WebpackLogger */

/** @typedef {ReturnType<Compilation["getCache"]>} CacheFacade */

/** @typedef {ReturnType<ReturnType<Compilation["getCache"]>["getLazyHashedEtag"]>} Etag */

/** @typedef {ReturnType<Compilation["fileSystemInfo"]["mergeSnapshots"]>} Snapshot */

/**
 * @typedef {boolean} Force
 */

/**
 * @typedef {Object} CopiedResult
 * @property {string} sourceFilename
 * @property {string} absoluteFilename
 * @property {string} filename
 * @property {Asset["source"]} source
 * @property {Force | undefined} force
 * @property {Record<string, any>} info
 */

/**
 * @typedef {string} StringPattern
 */

/**
 * @typedef {boolean} NoErrorOnMissing
 */

/**
 * @typedef {string} Context
 */

/**
 * @typedef {string} From
 */

/**
 * @callback ToFunction
 * @param {{ context: string, absoluteFilename?: string }} pathData
 * @return {string | Promise<string>}
 */

/**
 * @typedef {string | ToFunction} To
 */

/**
 * @typedef {"dir" | "file" | "template"} ToType
 */

/**
 * @callback TransformerFunction
 * @param {Buffer} input
 * @param {string} absoluteFilename
 * @returns {string | Buffer | Promise<string> | Promise<Buffer>}
 */

/**
 * @typedef {{ keys: { [key: string]: any } } | { keys: ((defaultCacheKeys: { [key: string]: any }, absoluteFilename: string) => Promise<{ [key: string]: any }>) }} TransformerCacheObject
 */

/**
 * @typedef {Object} TransformerObject
 * @property {TransformerFunction} transformer
 * @property {boolean | TransformerCacheObject} [cache]
 */

/**
 * @typedef {TransformerFunction | TransformerObject} Transform
 */

/**
 * @callback Filter
 * @param {string} filepath
 * @returns {boolean | Promise<boolean>}
 */

/**
 * @callback TransformAllFunction
 * @param {{ data: Buffer, sourceFilename: string, absoluteFilename: string }[]} data
 * @returns {string | Buffer | Promise<string> | Promise<Buffer>}
 */

/**
 * @typedef { Record<string, any> | ((item: { absoluteFilename: string, sourceFilename: string, filename: string, toType: ToType }) => Record<string, any>) } Info
 */

/**
 * @typedef {Object} ObjectPattern
 * @property {From} from
 * @property {GlobbyOptions} [globOptions]
 * @property {Context} [context]
 * @property {To} [to]
 * @property {ToType} [toType]
 * @property {Info} [info]
 * @property {Filter} [filter]
 * @property {Transform} [transform]
 * @property {TransformAllFunction} [transformAll]
 * @property {Force} [force]
 * @property {number} [priority]
 * @property {NoErrorOnMissing} [noErrorOnMissing]
 */

/**
 * @typedef {StringPattern | ObjectPattern} Pattern
 */

/**
 * @typedef {Object} AdditionalOptions
 * @property {number} [concurrency]
 */

/**
 * @typedef {Object} PluginOptions
 * @property {Pattern[]} patterns
 * @property {AdditionalOptions} [options]
 */

class CopyPlugin {
  /**
   * @param {PluginOptions} [options]
   */
  constructor(options = {
    patterns: []
  }) {
    validate(
    /** @type {Schema} */
    schema, options, {
      name: "Copy Plugin",
      baseDataPath: "options"
    });
    /**
     * @private
     * @type {Pattern[]}
     */

    this.patterns = options.patterns;
    /**
     * @private
     * @type {AdditionalOptions}
     */

    this.options = options.options || {};
  }
  /**
   * @private
   * @param {Compilation} compilation
   * @param {number} startTime
   * @param {string} dependency
   * @returns {Promise<Snapshot | undefined>}
   */


  static async createSnapshot(compilation, startTime, dependency) {
    // eslint-disable-next-line consistent-return
    return new Promise((resolve, reject) => {
      compilation.fileSystemInfo.createSnapshot(startTime, [dependency], // @ts-ignore
      // eslint-disable-next-line no-undefined
      undefined, // eslint-disable-next-line no-undefined
      undefined, null, (error, snapshot) => {
        if (error) {
          reject(error);
          return;
        }

        resolve(
        /** @type {Snapshot} */
        snapshot);
      });
    });
  }
  /**
   * @private
   * @param {Compilation} compilation
   * @param {Snapshot} snapshot
   * @returns {Promise<boolean | undefined>}
   */


  static async checkSnapshotValid(compilation, snapshot) {
    // eslint-disable-next-line consistent-return
    return new Promise((resolve, reject) => {
      compilation.fileSystemInfo.checkSnapshotValid(snapshot, (error, isValid) => {
        if (error) {
          reject(error);
          return;
        }

        resolve(isValid);
      });
    });
  }
  /**
   * @private
   * @param {Compiler} compiler
   * @param {Compilation} compilation
   * @param {Buffer} source
   * @returns {string}
   */


  static getContentHash(compiler, compilation, source) {
    const {
      outputOptions
    } = compilation;
    const {
      hashDigest,
      hashDigestLength,
      hashFunction,
      hashSalt
    } = outputOptions;
    const hash = compiler.webpack.util.createHash(
    /** @type {string} */
    hashFunction);

    if (hashSalt) {
      hash.update(hashSalt);
    }

    hash.update(source);
    const fullContentHash = hash.digest(hashDigest);
    return fullContentHash.toString().slice(0, hashDigestLength);
  }
  /**
   * @private
   * @param {typeof import("globby").globby} globby
   * @param {Compiler} compiler
   * @param {Compilation} compilation
   * @param {WebpackLogger} logger
   * @param {CacheFacade} cache
   * @param {ObjectPattern & { context: string }} inputPattern
   * @param {number} index
   * @returns {Promise<Array<CopiedResult | undefined> | undefined>}
   */


  static async runPattern(globby, compiler, compilation, logger, cache, inputPattern, index) {
    const {
      RawSource
    } = compiler.webpack.sources;
    const pattern = { ...inputPattern
    };
    const originalFrom = pattern.from;
    const normalizedOriginalFrom = path.normalize(originalFrom);
    logger.log(`starting to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context`);
    let absoluteFrom;

    if (path.isAbsolute(normalizedOriginalFrom)) {
      absoluteFrom = normalizedOriginalFrom;
    } else {
      absoluteFrom = path.resolve(pattern.context, normalizedOriginalFrom);
    }

    logger.debug(`getting stats for '${absoluteFrom}'...`);
    const {
      inputFileSystem
    } = compiler;
    let stats;

    try {
      stats = await stat(inputFileSystem, absoluteFrom);
    } catch (error) {// Nothing
    }
    /**
     * @type {"file" | "dir" | "glob"}
     */


    let fromType;

    if (stats) {
      if (stats.isDirectory()) {
        fromType = "dir";
        logger.debug(`determined '${absoluteFrom}' is a directory`);
      } else if (stats.isFile()) {
        fromType = "file";
        logger.debug(`determined '${absoluteFrom}' is a file`);
      } else {
        // Fallback
        fromType = "glob";
        logger.debug(`determined '${absoluteFrom}' is unknown`);
      }
    } else {
      fromType = "glob";
      logger.debug(`determined '${absoluteFrom}' is a glob`);
    }
    /** @type {GlobbyOptions & { objectMode: true }} */


    const globOptions = { ...{
        followSymbolicLinks: true
      },
      ...(pattern.globOptions || {}),
      ...{
        cwd: pattern.context,
        objectMode: true
      }
    }; // @ts-ignore

    globOptions.fs = inputFileSystem;
    let glob;

    switch (fromType) {
      case "dir":
        compilation.contextDependencies.add(absoluteFrom);
        logger.debug(`added '${absoluteFrom}' as a context dependency`);
        pattern.context = absoluteFrom;
        glob = path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom))), "**/*");
        absoluteFrom = path.join(absoluteFrom, "**/*");

        if (typeof globOptions.dot === "undefined") {
          globOptions.dot = true;
        }

        break;

      case "file":
        compilation.fileDependencies.add(absoluteFrom);
        logger.debug(`added '${absoluteFrom}' as a file dependency`);
        pattern.context = path.dirname(absoluteFrom);
        glob = fastGlob.escapePath(normalizePath(path.resolve(absoluteFrom)));

        if (typeof globOptions.dot === "undefined") {
          globOptions.dot = true;
        }

        break;

      case "glob":
      default:
        {
          const contextDependencies = path.normalize(globParent(absoluteFrom));
          compilation.contextDependencies.add(contextDependencies);
          logger.debug(`added '${contextDependencies}' as a context dependency`);
          glob = path.isAbsolute(originalFrom) ? originalFrom : path.posix.join(fastGlob.escapePath(normalizePath(path.resolve(pattern.context))), originalFrom);
        }
    }

    logger.log(`begin globbing '${glob}'...`);
    /**
     * @type {GlobEntry[]}
     */

    let globEntries;

    try {
      globEntries = await globby(glob, globOptions);
    } catch (error) {
      compilation.errors.push(
      /** @type {WebpackError} */
      error);
      return;
    }

    if (globEntries.length === 0) {
      if (pattern.noErrorOnMissing) {
        logger.log(`finished to process a pattern from '${normalizedOriginalFrom}' using '${pattern.context}' context to '${pattern.to}'`);
        return;
      }

      const missingError = new Error(`unable to locate '${glob}' glob`);
      compilation.errors.push(
      /** @type {WebpackError} */
      missingError);
      return;
    }
    /**
     * @type {Array<CopiedResult | undefined>}
     */


    let copiedResult;

    try {
      copiedResult = await Promise.all(globEntries.map(
      /**
       * @param {GlobEntry} globEntry
       * @returns {Promise<CopiedResult | undefined>}
       */
      async globEntry => {
        // Exclude directories
        if (!globEntry.dirent.isFile()) {
          return;
        }

        if (pattern.filter) {
          let isFiltered;

          try {
            isFiltered = await pattern.filter(globEntry.path);
          } catch (error) {
            compilation.errors.push(
            /** @type {WebpackError} */
            error);
            return;
          }

          if (!isFiltered) {
            logger.log(`skip '${globEntry.path}', because it was filtered`);
            return;
          }
        }

        const from = globEntry.path;
        logger.debug(`found '${from}'`); // `globby`/`fast-glob` return the relative path when the path contains special characters on windows

        const absoluteFilename = path.resolve(pattern.context, from);
        const to = typeof pattern.to === "function" ? await pattern.to({
          context: pattern.context,
          absoluteFilename
        }) : path.normalize(typeof pattern.to !== "undefined" ? pattern.to : "");
        const toType = pattern.toType ? pattern.toType : template.test(to) ? "template" : path.extname(to) === "" || to.slice(-1) === path.sep ? "dir" : "file";
        logger.log(`'to' option '${to}' determinated as '${toType}'`);
        const relativeFrom = path.relative(pattern.context, absoluteFilename);
        let filename = toType === "dir" ? path.join(to, relativeFrom) : to;

        if (path.isAbsolute(filename)) {
          filename = path.relative(
          /** @type {string} */
          compiler.options.output.path, filename);
        }

        logger.log(`determined that '${from}' should write to '${filename}'`);
        const sourceFilename = normalizePath(path.relative(compiler.context, absoluteFilename)); // If this came from a glob or dir, add it to the file dependencies

        if (fromType === "dir" || fromType === "glob") {
          compilation.fileDependencies.add(absoluteFilename);
          logger.debug(`added '${absoluteFilename}' as a file dependency`);
        }

        let cacheEntry;
        logger.debug(`getting cache for '${absoluteFilename}'...`);

        try {
          cacheEntry = await cache.getPromise(`${sourceFilename}|${index}`, null);
        } catch (error) {
          compilation.errors.push(
          /** @type {WebpackError} */
          error);
          return;
        }
        /**
         * @type {Asset["source"] | undefined}
         */


        let source;

        if (cacheEntry) {
          logger.debug(`found cache for '${absoluteFilename}'...`);
          let isValidSnapshot;
          logger.debug(`checking snapshot on valid for '${absoluteFilename}'...`);

          try {
            isValidSnapshot = await CopyPlugin.checkSnapshotValid(compilation, cacheEntry.snapshot);
          } catch (error) {
            compilation.errors.push(
            /** @type {WebpackError} */
            error);
            return;
          }

          if (